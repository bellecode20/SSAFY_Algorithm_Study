**03/17 월**
강사님이 수업시간에 주신 과제 중 안전 영역 문제를 풀이했다.
BFS로 델타 탐색을 하면 쉽게 풀릴 것 같은 문제인데, DFS로 풀어보라고 하셨다.
근데 사실 내 지금 코드 로직은 BFS 델타 탐색과 크게 다르지 않다..
재귀 호출에서 maximum recursion 때문에 런타임 에러가 나와서 그냥 recursion을 import를 사용해서 늘려줬는데..
+) 이렇게 하는 게 맞다고 한다

***

**03/18 화**
백준의 단어 수학 문제는 그리디하게 풀이할 수 있는 규칙성만 찾는다면 G4가 아닌 실버정도로 느껴질 정도로 쉽게 풀이할 수 있는 문제였다. 알고리즘 풀이를 하면서 dictionary 자료형을 거의 안 써서 뭔가 아이디어를 생각하는 게 좀 시간이 걸렸다.

***

**03/19 수**
SWEA 등산로 조성 문제는 백트래킹을 활용해 풀이하는 문제였다. 지형을 K만큼 1번 깎을 수 있다는 걸 플래그와 같이 생각하면 쉽게 풀이할 수 있는 문제였다. 델타 이동을 할 때, 이전 좌표보다 다음 좌표가 최대 K만큼을 깎았을 때 이동 가능한 좌표라는 가능성만 확인되면, 주어진 K에서 얼마만큼 깎을 지는 고려할 필요 없이 이전 좌표보다 -1만큼 작게 설정하는 아이디어로 풀이했다. (이 때문에 dfs 호출 전에 시작좌표에 visited를 처리하지 않았을 땐, 일부 테스트 케이스가 틀리는 문제가 생겼었다.)

***

**03/20 목**
MST(최소신장트리) 알고리즘 개념을 사용해 풀이하는 다리만들기2 문제를 풀이를 시도했으나.. 로직은 BFS로 섬 번호를 매긴 뒤 최소 거리를 다 graph에 인접행렬로 계산해 프림을 통해 구하는 방법으로 풀이했으나.. 시간 초과가 납니다... 일단 코드가 너무 길어져서 어디서 어떻게 해결해야 할 지 막막해서.. 일단 좀 자고 맑은 정신으로 내일 다시 풀어보겠습니다

+) 처음에 섬 번호를 매길 때, visited처리를 제대로 안해서 무한 루핑 도는 문제였습니다. 로직은 문제가 없었고, visited를 리스트 좌표가 아닌 튜플에 좌표를 add 했을 때 연산속도가 조금 더 빨라진다고 해서 활용해봤습니다.

***

**03/21 금**
"다리만들기 2"문제와 유사한 BFS 델타 탐색 개념을 활용한 "다리 만들기" 문제를 풀이했다. 다리만들기 2를 풀면서 경계값을 따로 관리하지 않고 매긴 섬 번호가 다를 때까지 다리를 연결하는 로직을 완전 탐색한 코드가 많이 아쉬웠어서, 이번에는 아이디어적으로 풀이하고 싶어서,

1. bfs로 섬 번호를 매기기 위한 델타 탐색을 하면서 0 값을 만났을 때, cy cx값을 edge에 저장
2. 저장된 튜플 값을 섬 번호를 key로 관리하고 있는 딕셔너리에 저장
3. 다리를 연결하기 위한 bfs 델타 탐색을 할 때 섬 전체를 도는 것이 아닌 경계 좌표에서만 출발해 다른 섬과 만났을 때의 최소 거리 갱신하는 아이디어로 풀이해봤다.

최근에 알고리즘을 풀이하면서 dict 자료형을 써보려고 노력 중이다. (매번 쓰던 자료형에만 익숙해지면 나중에 필요한 상황에서 적용하기가 힘들 것 같아서 연습 중이다!)

***

**03/22 토**
금요일 라이브 풀이 문제중 하나였던 '숫자 만들기' 문제를 시간이 부족해 풀이하지 못한 게 기억나서 다시 풀어봤다.
대표적인 dfs 백트래킹 문제였고, 나눗셈 정수 소수점을 어떻게 버리는 방법에 대해 int 자료형을 쓰는 방법을 선택했다.

int()는 소수점 이하를 버림(floor)하는 것이 아니라 0을 기준으로 내림(truncate) 연산을 수행할 수 있어,
1. 양수일 때, int()와 // 연산이 동일하고
2. 음수일 때, int()는 양수에서 변환한 것처럼 0 방향으로 절삭 연산을 수행한다는 특징이 있어,
의도하지 않은 반올림을 수행하지 않고 소수점을 버리는 계산을 할 수 있었다.
if else 구문으로 음수일 경우를 따로 나눠서 계산하지 않아도 한 줄로 경우의 수를 모두 계산할 수 있었다. 

***

**03/23 일**
강사님이 추천해주신 문제 중, 백준에 있는 "캐슬 디펜스" 문제를 풀이했다.
뭔가 그냥 처음에 문제를 읽었을 때는 bfs 델타 탐색 + 조합 문제처럼 보였다. 근데 문제를 풀이하면서,
아래의 조건을 보고
[조건] 격자판의 두 위치 (r1, c1), (r2, c2)의 거리는 |r1-r2| + |c1-c2|이다.

굳이 델타 탐색을 해야할까? 라는 생각이 들었다. (예전 같았으면, 냅다 델타 탐색 코드를 짰을 것 같은데..)
그냥 문제에 주어진 조건대로 함수 내에서 최소 거리를 구하고, 최소 거리가 같을 경우 맨 왼쪽부터 적을 타겟하도록 함수를 짰다. 그리고 적들은 그냥 무조건 아래로 이동하므로, 다른 방향 고려할 필요 없이 공격이 끝나면 그냥 y좌표를 +1씩 해주도록 함수를 짰다.

그냥 성벽에 배치할 궁수들의 조합을 구하고, 최소 거리를 구해서 적을 제거하는 구현문제(?)에 가까운 것 같았다.

뭔가 게임을 하는 느낌이 들어서 재밌게 풀이한 것 같다!